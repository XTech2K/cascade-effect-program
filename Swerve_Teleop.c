#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S2, HTServo,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     FR,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     FL,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     BR,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     BL,            tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C1_1,    FR,                   tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    FL,                   tServoStandard)
#pragma config(Servo,  srvo_S2_C1_3,    BR,                   tServoStandard)
#pragma config(Servo,  srvo_S2_C1_4,    BL,                   tServoStandard)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

int mode = 0;
string direction = "up";

void initializeRobot()
{

	return;
}

task directionCont(){
	while(mode == 0){
		getJoystickSettings(joystick);
		if(joystick.joy1_TopHat == 0){
			direction = "up";
			}else if(joystick.joy1_TopHat == 2){
			direction = "right";
			}else if(joystick.joy1_TopHat == 4){
			direction = "down";
			}else if(joystick.joy1_TopHat == 6){
			direction = "left";
		}
		abortTimeslice();
	}
}

float DZ(float input){
	if(input < 15 && input > -15){
		return 0;
	}else{
		return input;
	}
}

task driveHolo(){
	startTask(directionCont);
	int turn;
	while(mode == 0){
		getJoystickSettings(joystick);
		turn = joystick.joy1_x2/10;
		switch(direction){
			case 'up':
				motor[C] = (((DZ(joystick.joy1_y1)+DZ(joystick.joy1_x1))/128.0)*75) - turn;
				motor[D] = (((DZ(joystick.joy1_y1)-DZ(joystick.joy1_x1))/128.0)*75) - turn;
				motor[A] = -(((DZ(joystick.joy1_y1)+DZ(joystick.joy1_x1))/128.0)*75) - turn;
				motor[B] = (((DZ(joystick.joy1_x1)-DZ(joystick.joy1_y1))/128.0)*75) - turn;

			case 'right':
				motor[D] = ((((DZ(joystick.joy1_y1))+DZ(joystick.joy1_x1))/128.0)*100) - turn;
				motor[A] = ((((DZ(joystick.joy1_y1))-DZ(joystick.joy1_x1))/128.0)*100) - turn;
				motor[B] = -((((DZ(joystick.joy1_y1))+DZ(joystick.joy1_x1))/128.0)*100) - turn;
				motor[C] = ((((DZ(joystick.joy1_x1))-DZ(joystick.joy1_y1))/128.0)*100) - turn;

			case 'down':
				motor[D] = ((((DZ(joystick.joy1_y1))+DZ(joystick.joy1_x1))/128.0)*100) - turn;
				motor[A] = ((((DZ(joystick.joy1_y1))-DZ(joystick.joy1_x1))/128.0)*100) - turn;
				motor[B] = -((((DZ(joystick.joy1_y1))+DZ(joystick.joy1_x1))/128.0)*100) - turn;
				motor[C] = ((((DZ(joystick.joy1_x1))-DZ(joystick.joy1_y1))/128.0)*100) - turn;

			case 'left':
				motor[B] = ((((DZ(joystick.joy1_y1))+DZ(joystick.joy1_x1))/128.0)*100) - turn;
				motor[C] = ((((DZ(joystick.joy1_y1))-DZ(joystick.joy1_x1))/128.0)*100) - turn;
				motor[D] = -((((DZ(joystick.joy1_y1))+DZ(joystick.joy1_x1))/128.0)*100) - turn;
				motor[A] = ((((DZ(joystick.joy1_x1))-DZ(joystick.joy1_y1))/128.0)*100) - turn;
		}
	}
}

task driveTank(){
	while(true){
    if(active){
      getJoystickSettings(joystick);
      motor[left] = pow((DZ(joystick.joy1_y1)/128.0), 3)*100;
      motor[right] = pow((DZ(joystick.joy1_y2)/128.0), 3)*100;
		}
	}
}

task modeControl(){
	mode = 0;
	goHolo();
	startTask(driveHolo);
	while(true){
		getJoystickSettings(joystick);
		if(joy1Btn(5) == 1){
			if(mode == 0){
				mode = 1
				goTank();
				startTask(driveTank);
			}
			else{
				mode == 0;
				goHolo();
				startTask(driveHolo);
			}
		}
	}
}

task main()
{
	initializeRobot();

	startTask(modeControl);

	while (true){
	}
}
